\section{Overview}

CAD (computer-aided design) software is used by architects, engineers, drafters, artists, and others to create precision drawings or technical illustrations. CAD software can be used to create two-dimensional (2-D) drawings or three-dimensional (3-D) models.

The drafting work can be automated and accelerated through the use of computer aided design systems. It may be applied for a wide variety of products in the field of automotive electronics, aerospace, naval, architecture, civil and other disciplines of engineering. CAD systems were originally used for automated drafting only. But now they also include three-dimensional modeling and computer simulated operations of the models. Sometimes, CAD is translated as computer assisted drafting, computer aided drafting or a similar phrase. Related acronyms are CADD which stands for Computer Aided design and Drafting, CAID for Computer Aided Industrial design, CAAD for Computer Aided Architectural design. All these terms are essentially synonymous, but there are some subtle differences in meaning and appliation.

CAD is used to design, develop and optimize products, which can be goods used by end consumers or intermediate good used in other products. CAD is also extensively used in the design of tools and equipment required in the manufacturing process, and in the drafting and design and design of all types of buildings, ranging from small residential houses to the largest commercial or Industrial complexes. CAD enables designers to layout and to develop their work on a computer screen, print and save it for future editing, thus saving a lot of time on their drawings. CAD is mainly used for detailed engineering of 3D models and/or 2D drawings of physical components, but it is also used throughout the engineering process, form conceptual design and layout of products to definition of manufacturing methods of components. Rather thatn building prototypes and changing components to determine the effects of tolerance ranges, engineers can use CAD systems to simulate operation to determine loads and stresses. The major benefits of such systems include lower product development costs and a greatly shortened design cycle. The CAD systems running on workstations and mainframe computers are increasingly integrated with computer-aided manufacturing systems.

\section{Introduction To Project} 
Automated Building Drawing is a project for creating two-dimensional drawings. The main purpose or objective of the project is to make it usable even by a layman. The main target users are the Civil Engineers who want their plans to be printed on the sheets. As of now, they have to create the drawings with the use of paper and pencil. So to automate converting a particular drawing model to the print ready drawings, this project will be beneficial. The interface should be easy
to use and pretty intuitive. Because the interface is a thing that makes user experience better and to make the user use it.
The Drawing module allows you to put your work on computer. That is, to put views of your models in a 2D window and to insert that window in a drawing, for example a sheet with a border, a wall and a circle and finally print that sheet.

The user will have to input the parameters like name of the entity it's specifications (like dimensions etc.) in an input file and that's it. Next, that data is parsed from the input file and then fed to the DXF entities functions. Hence, just in a few lines the design is generated. And it will take lesser time and efforts that working on a professional CAD software that requires more skills.


\section{Objectives}
\begin{itemize}
	\item To put views of your models in a 2D window and to insert that window in a drawing.
	\item To increase the productivity and hence efficiency.
	\item To encourage civil engineers to use the computer instead of drawing sheets.
	\item To create the drawings of various entities without using the mouse.
	\item To eliminate manual operations and thus saving the time and money by automating the entire drawing process.
\end{itemize}



\section{Feasibility Study}
Feasibility study is made to see if the project on completion will serve the purpose of the organization for the amount of work, effort and the time that spend on it. Feasibility study lets the developer foresee the future of the project and the usefulness. A feasibility study of a system proposal is according to its workability, which is the impact on the organization, ability to meet their user needs and effective use of resources. Carrying out a feasibility study involves information assessment, information collection and report writing. The information assessment phase identifies the information that is required to answer the three questions set out above. Once the information has been identified, you should question information sources to discover the answers to these questions Thus when a new application is proposed it normally goes through a feasibility study before it is approved for development.

A feasibility study is designed to provide an overview of the primary issues related to a business idea.  The purpose is to identify any “make or break” issues that would prevent your business from being successful in the marketplace. In other words, a feasibility study determines whether the business idea makes sense. A thorough feasibility analysis provides a lot of information necessary for the business plan.  For example, a good market analysis is necessary in order to determine the project’s feasibility.  This information provides the basis for the market section of the business plan.

The document provide the feasibility of the project that is being designed and lists various areas that were considered very carefully during the feasibility study of this project such as Technical, Economic and Operational feasibilities. Feasibility is defined as the practical extent to which a project can be performed successfully. To evaluate feasibility, a feasibility study is performed, which determines whether the solution considered to accomplish the requirements is practical and workable in the software. Information such as resource availability, cost estimation for software development, benefits of the software to the organization after it is developed and cost to be incurred on its maintenance are considered during the feasibility study. The objective of the feasibility study is to establish the reasons for developing the software that is acceptable to users, adaptable to change and conformable to established standards.

Objectives of feasibility study are listed below.
\begin{itemize}
	\item To analyze whether the software will meet organizational requirements
	\item To determine whether the software can be implemented using the current technology and within the specified budget and schedule
	\item To determine whether the software can be integrated with other existing software.
\end{itemize}

\subsection{Types of Feasibility}
Various types of feasibility that are commonly considered include technical feasibility, operational feasibility, and economic feasibility.

\subsubsection{Technical Feasibility}
Technical feasibility is one of the first studies that must be conducted after the project has been identified. In large engineering projects consulting agencies that have large staffs of engineers and technicians conduct technical studies dealing with the projects. In individual agricultural projects financed by local agricultural credit corporations, the technical staff composed of specialized agricultural engineers, irrigation and construction engineers, and other technicians are responsible for conducting such feasibility studies. The technical feasibility assessment is focused on gaining an understanding of the present technical resources of the organization and their applicability to the expected needs of the proposed system. It is an evaluation of the hardware and software and how it meets the need of the proposed system. This assessment is based on an outline design of system requirements, to determine whether the company has the technical expertise to handle completion of the project. When writing a feasibility report, the following should be taken to consideration:
\begin{itemize}
	\item A brief description of the business to assess more possible factors which could affect the study
	\item The part of the business being examined
	\item The human and economic factor
	\item The possible solutions to the problem
\end{itemize}

The system must be evaluated from the technical point of view first. The assessment of this feasibility must be based on an outline design of the system requirement in the terms of input, output, programs and procedures. Having identified an outline system, the investigation must go on to suggest the type of equipment, required method developing the system, of running the system once it has been designed. Technical feasibility assesses the current resources (such as hardware and software) and technology, which are required to accomplish user requirements in the software within the allocated time and budget. For this, the software development team ascertains whether the current resources and technology can be upgraded or added in the software to accomplish specified user requirements. Technical feasibility also performs the following tasks.

\begin{itemize}
	\item Analyzes the technical skills and capabilities of the software development team members
	\item Determines whether the relevant technology is stable and established
	\item Ascertains that the technology chosen for software development has a large number of users so that they can be consulted when problems arise or improvements are required.
\end{itemize}

Technical issues raised during the investigation are:
\begin{itemize}
	\item Does the existing technology sufficient for the suggested one?
	\item Can the system expand if developed?
\end{itemize}

The project should be developed such that the necessary functions and performance are achieved within the constraints. The project is developed within latest technology. Through the technology may become obsolete after some period of time, due to the fact that never version of same software supports older versions, the system may still be used. So there are minimal constraints involved with this project. The system has been developed using Java the project is technically feasible for development.

\subsubsection{Economic Feasibility}
The purpose of the economic feasibility assessment is to determine the positive economic benefits to the organization that the proposed system will provide. It includes quantification and identification of all the benefits expected. This assessment typically involves a cost/ benefits analysis.

Economic feasibility is the cost and logistical outlook for a business project or endeavor. Prior to embarking on a new venture, most businesses conduct an economic feasibility study, which is a study that analyzes data to determine whether the cost of the prospective new venture will ultimately be profitable to the company. Economic feasibility is sometimes determined within an organization, while other times companies hire an external company that specializes in conducting economic feasibility studies for them.

The purpose of business in a capitalist society is to turn a profit, or to earn positive income. While some ideas seem excellent when they are first presented, they are not always economically feasible. That is, that they are not always profitable or even possible within a company's budget. Since companies often determine their budget's several months in advance, it is necessary to know how much of the budget needs to be set aside for future projects. Economic feasibility helps companies determine what that dollar amount is before a project is ultimately approved. This allows companies to carefully manage their money to insure the most profitable projects are undertaken. Economic feasibility also helps companies determine whether or not revisions to a project that at first seems unfeasible will make it feasible.

The developing system must be justified by cost and benefit. Criteria to ensure that effort is concentrated on project, which will give best, return at the earliest. One of the factors, which affect the development of a new system, is the cost it would require. Economic feasibility determines whether the required software is capable of generating financial gains for an organization. It involves the cost incurred on the software development team, estimated cost of hardware and software, cost of performing feasibility study, and so on. For this, it is essential to consider expenses made on purchases (such as hardware purchase) and activities required to carry out software development. In addition, it is necessary to consider the benefits that can be achieved by developing the software. Software is said to be economically feasible if it focuses on the issues listed below.
\begin{itemize}
	\item Cost incurred on software development to produce long-term gains for an organization.
	\item Cost required to conduct full software investigation (such as requirements elicitation and requirements analysis).
	\item Cost of hardware, software, development team, and training.
\end{itemize}

The following are some of the important financial questions asked during preliminary investigation:
\begin{itemize}
	\item The costs conduct a full system investigation.
	\item The cost of the hardware and software.
	\item The benefits in the form of reduced costs or fewer costly errors.
\end{itemize}

Since the system is developed as part of project work, there is no manual cost to spend for the proposed system. Also all the resources are already available, it give an indication of the system is economically possible for development.

\subsubsection{Behavioral Feasibility}
Behavioral feasibility assesses the extent to which the required software performs a series of steps to solve business problems and user requirements. It is a measure of how well the solution of problems or a specific alternative solution will work in the organization. It is also measure of how people feel about the system. If the system is not easy to operate, than operational process would be difficult. The operator of the system should be given proper training. The system should be made such that the user can interface the system without any problem.

Operational feasibility is a measure of how well a proposed system solves the problems, and takes advantage of the opportunities identified during scope definition and how it satisfies the requirements identified in the requirements analysis phase of system development. The operational feasibility assessment focuses on the degree to which the proposed development projects fits in with the existing business environment and objectives with regard to development schedule, delivery date, corporate culture, and existing business processes.

To ensure success, desired operational outcomes must be imparted during design and development. These include such design-dependent parameters such as reliability, maintainability, supportability, usability, producibility, disposability, sustainability, affordability and others. These parameters are required to be considered at the early stages of design if desired operational behaviors are to be realized. A system design and development requires appropriate and timely application of engineering and management efforts to meet the previously mentioned parameters. A system may serve its intended purpose most effectively when its technical and operating characteristics are engineered into the design. Therefore, operational feasibility is a critical aspect of systems engineering that needs to be an integral part of the early design phasesThis feasibility is dependent on human resources (software development team) and involves visualizing whether the software will operate after it is developed and be operative once it is installed. Operational feasibility also performs the following tasks.

\begin{itemize}
	\item Determines whether the problems anticipated in user requirements are of high priority.
	\item Determines whether the solution suggested by the software development team is acceptable.
	\item Analyzes whether users will adapt to a new software.
	\item Determines whether the organization is satisfied by the alternative solutions proposed by the software development team.
\end{itemize}

This includes the following questions:
\begin{itemize}
	\item Is there sufficient support for the users?
	\item Will the proposed system cause harm?
	\item The project would be beneficial because it satisfies the objectives when developed and installed. All behavioral aspects are considered carefully and conclude that the project is behaviorally feasible.
\end{itemize}

\section{Software Requirement Analysis}
Software requirement analysis is a process of gathering and interpreting facts, diagnosing problems and the information to recommend improvements on the system. It is a problem solving activity that requires intensive communication between the system users and system developers. System analysis or study is an important phase of any system development process. The system is studied to the minutest detail and analyzed. The system analyst plays the role of the interrogator and dwells deep into the working of the present system. The system is viewed as a whole and the input to the system are identified. The outputs from the organizations are traced to the various processes. System analysis is concerned with becoming aware of the problem, identifying the relevant and decisional variables, analyzing and synthesizing the various factors and determining an optimal or at least a satisfactory solution or program of action.\\

\noindent A detailed study of the process must be made by various techniques like interviews, questionnaires etc. The data collected by these sources must be scrutinized to arrive to a conclusion. The conclusion is an understanding of how the system functions. This system is called the existing system. Now the existing system is subjected to close study and problem areas are identified. The designer now functions as a problem solver and tries to sort out the difficulties that the enterprise faces. The solutions are given as proposals. The proposal is then weighed with the existing system analytically and the best one is selected. The proposal is presented to the user for an endorsement by the user. The proposal is reviewed on user request and suitable changes are made. This is loop that ends as soon as the user is satisfied with proposal.\\

\noindent Preliminary study is the process of gathering and interpreting facts, using the information for further studies on the system. Preliminary study is problem solving activity that requires intensive communication between the system users and system developers. It does various feasibility studies. In these studies a rough figure of the system activities can be obtained, from which the decision about the strategies to be followed for effective system study and analysis can be taken.

\section{User Characteristics}
The objective of  Automated Building Drawings is to give facility to the user to make the drawings of any particular building. User can choose any particular entities from the system. First of all user has to select an entity for example if he wants to draw a wall he has to specify the type of entity to be drawn. Then later the user has to specify the parameters of the entity selected. User can select any of the entities supported by the system and can see the drawing of the same entity as the output on the screen. Also, the system has the feature to save the drawings in the dxf file format which can be opened later using the CAD software like LibreCAD. Thus, the Automated Building Drawings system allows the user to save all the drawings drawn into the computer thus user does not have to keep the old drawing sheets for future reference.

The basic workflow of using, by the user's point of view, will be to edit a normal text file. Then execution of the program will take place. The parsing will be done of the input file that user has just written and divided into small tokens. That can also be seen in a file named output.txt (just for debugging purposes).

\section{Technologies Used}
\subsection{C++}
\noindent C++ is one of the most popular programming languages and is implemented on a wide variety of hardware and operating system platforms. As an efficient compiler to native code, its application domains include systems software, application software, device drivers, embedded software, high- performance server and client applications, and entertainment software such as video games. Several groups provide both free and proprietary C++ compiler software, including the GNU Project, Microsoft, Intel and Embarcadero Technologies. C++ has greatly influenced many other
popular programming languages, most notably C\# and Java. Other successful languages such as Objective- C use a very different syntax and approach to adding classes to C.\\

\noindent Bjarne Stroustrup began his work on C with Classes in 1979. The idea of creating a new language originated from Stroustrups experience in programming for his Ph.D. thesis. Stroustrup found that Simula had features that were very helpful for large software development, but the language was too slow for practical use, while BCPL was fast but too low-level to be suitable for large software development. When Stroustrup started working in AT\&T Bell Labs, he had the problem of analyzing the UNIX kernel with respect to distributed computing. Remembering his Ph.D. experience, Stroustrup set out to enhance the C language with Simula-like features. C was chosen because it was general-purpose, fast, portable and widely used. Besides C and Simula, some other languages
that inspired him were ALGOL 68, Ada, CLU and ML. At first, the class, derived class, strong type checking, inlining, and default argument features were added to C via Stroustrups C++ to C compiler, Cfront. The first commercial implementation of C++ was released on 14 October 1985.

\subsection{Introduction To Qt}
\noindent Qt Creator is a complete IDE for creating applications with Qt Quick and the Qt application framework. Qt is designed for developing applications and user interfaces once and deploying them across several desktop and mobile operating systems. One of the major advantages of Qt Creator is that it allows a team of developers to share a project across different development platforms (Microsoft Windows, Mac OS X, and Linux) with a common tool for development and debugging.
In addition, UI designers can join the team by using Qt Quick tools for creating fluid user interfaces in close cooperation with the developers. The main goal for Qt Creator is meeting the development needs of Qt Quick developers who are looking for simplicity, usability, productivity, extendibility and openness, while aiming to lower the barrier of entry for newcomers to Qt Quick and Qt. The key features of Qt Creator allow UI designers and developers to accomplish the following tasks:
\begin{itemize}
\item Get  started  with  Qt  Quick  application  development  quickly  and  easily  with  examples,  tutorials,
and project wizards.
\item Design  application  user  interface  with  the  integrated  editor,  Qt  Quick  Designer,  or  use graphics
software to design the user interface and use scripts to export the design to Qt Quick Designer.
\item Develop  applications   with  the   advanced  code  editor  that  provides  new  powerful  features  for
copleting code snippets, refactoring code, and viewing the element hierarchy of QML files.
\item Build  and  deploy  Qt  Quick  applications  that  target  multiple  desktop and mobile platforms, such
as Microsoft Windows, Mac OS X, Linux, Symbian, MeeGo, and Maemo.
\item Debug  JavaScript  functions  and  execute  JavaScript  expressions  in  the  current  context,   and
inspect QML at runtime to explore the object structure, debug animations, and inspect colors.
\item Profile  your  Qt  Quick  applications  with  the  QML  Profiler.  You can inspect binding evaluations,
signal  handling,  and  painting  operations  when  running  QML  code.  This  is  useful  for  identifying
potential bottlenecks, especially in the evaluation of bindings.
\item Deploy  applications  to  mobile  devices  and  create  application  installation  packages  for  Symbian
and Maemo devices that can be published in the Ovi Store and other channels.
\item Easily access information with the integrated context­sensitive Qt Help system.
\item It has differents modes such as Welcome, edit debug, design,analyze and help
\end{itemize}

\subsection{dxflib}
dxflib is an open source C++ library mainly for parsing DXFTM files. QCAD, CAM Expert and vec2web all use dxflib to import DXF files. dxflib can also write DXF files, but you need to have good knowledge of the DXF format to produce valid output.

dxflib is a C++ library for reading and writing DXF files. When reading DXF files, dxflib parses the file and calls functions that you define in your own C++ class for adding entities, layers, ..
Please note that dxflib does not store any entities or other information for you. It only passes the supported entities and other objects found in the DXF file to your C++ class.
Using dxflib to read DXF files doesn't require any knowlege of the DXF format. However, it's still an advantage to know the basics about entities, attributes, layers and blocks. To write DXF files with dxflib you definitely need an idea of how a DXF file is organized.
dxflib does not depend on any exotic other libraries, just the standard C / C++ libraries.

\subsubsection{Features}
\subsubsection*{Supported DXF Format Sections}
\begin{lstlisting}
HEADER
	Variables
TABLES
	LAYER
BLOCKS
ENTITIES
	3DFACE
	ARC
	CIRCLE
	DIMENSION
		Aligned
		Linear
		Radial
		Diametric
		Angular
		Leader
	ELLIPSE
	HATCH
	INSERT
	LINE
	LWPOLYLINE
	POINT
	POLYLINE
	SPLINE
	SOLID
	TEXT
\end{lstlisting}

\subsubsection{Compiling dxflib}
\subsubsection*{Unix / Linux}

Under Unix and Linux Systems, compiling dxflib is a simple standard procedure:

\begin{verbatim*}
./configure
make
\end{verbatim*}

This creates the file './lib/dxflib.a' . To compile a dynamic version of dxflib, run 'make shared' instead of 'make' . This will create the file 
'./lib/libdxf.so.2.0.x.x' and the link './lib/libdxf.so' that points to './lib/libdxf.so.2.0.x.x' .
Instead of running 'make install', you can also copy the header files into a header directory of your choice and copy the library files into a library directory of your choice.

\subsubsection*{Windows}
There are many different ways to compile dxflib under Windows. You can use Microsoft's Visual C++ compiler, Borland's C++ command line tools, gcc and many other compilers. 
For this manual, only the process of compiling dxflib using cygwin [CYGWIN] and the gcc compiler from the MinGW32 package is shown:
\begin{verbatim*}
./configure
MinGW32-make
\end{verbatim*}
\subsubsection{Reading DXF Files}
\begin{figure}
\centering
\includegraphics[scale=0.8]{images/dxflib.png}
\caption{dxflib workflow}
\label{fig:dxflib}
\end{figure}

dxflib parses DXF files and calls functions in your class. In those functions you can for example add the entities to an entity container. The basic workflow can be seen in the Figure \ref{fig:dxflib}.

\subsubsection{Implementing the Creation Interface}
Your C++ class that handles DXF entities has to be derived from DL\_CreationInterface or DL\_CreationAdapter. In most cases DL\_CreationAdapter is more convenient because it doesn't force you to implement all functions.
\begin{verbatim}
class MyDxfFilter : public DL_CreationAdapter {
    virtual void addLine(const DL_LineData& d);
    ...
}
\end{verbatim}


The implementation of the functions in your class will typically add the entities to a container of entities or use the information in another way.

\begin{verbatim}
void MyDxfFilter::addLine(const DL_LineData& d) {
    std::cout << "Line: " << d.x1 << "/" << d.y1
    << " " << d.x2 << "/" << d.y2 << std::endl;
}
\end{verbatim}

When reading a DXF file you simply pass on a reference to an object of your class to the parser.

\begin{verbatim}
MyDxfFilter f;
DL_Dxf* dxf = new DL_Dxf();
if (!dxf->in("drawing.dxf", &f)) {
    std::cerr << "drawing.dxf could not be opened.\n";
}
delete dxf;
\end{verbatim}



\subsubsection{Writing DXF Files}
To write a DXF file, you need to wrap the entities, layers, blocks, .. you have into the wrapper classes of dxflib. Since dxflib does not store any entities, you need to iterate through your entities and call the write functions for each of them. Please note that you have to stick to the exact order in which you call the write functions of dxflib. Otherwise your DXF file will not be standard conform.

\subsubsection{Creating the Writer Object}
To create a DXF writer object you need to specify the file name as well as the DXF version you want to produce. At the time of writing only two DXF versions were supported: R12 and DXF 2000/2002. The dxflib codes for DXF version R12 is DL\_Codes::AC1009 and for DXF 2000/2002 DL\_Codes::AC1015.
There are two APIs you will need to write a DXF file. The API in DL\_WriterA offers low level functions to write basic key/value tuples on which a DXF file is based. Creating a valid DXF file using only these functions would be very difficult and inconvenient. Therefore, there is a higher level API in the DL\_Dxf class which allows you to write for example a whole line without knowing the key/value tuples that are needed for it.


\subsubsection{Writing the DXF Header}
\subsubsection*{Opening the DXF Header}
The DXF header contains information about the DXF version. It has to be written before anything else with
\begin{verbatim}
dxf.writeHeader(*dw);
\end{verbatim}
The following list shows how a DXF header typically looks like:
\begin{verbatim}
999
dxflib 2.0.4.8
  0
SECTION
  2
HEADER
  9
$ACADVER
  1
AC1015
  9
$HANDSEED
  5
FFFF
\end{verbatim}

As you can see, the writeHeader() function does not close the header. This is because you might want to store a set of variables into it. If you have to store variables, you have to do it now. If not, proceed with "Closing the Header".

\subsubsection*{Storing Additional Variables}
Variables in the DXF header are used to store meta data for the drawing contained in the file. For a description of all supported variables, please refer to the DXF documentation [DXF].
The following code snippet shows examples for storing variables of different types. You can store as many variables as you need but you have to stick to the supported variable names and types in order to create a valid DXF file.


The following code creates and opens a file for a DXF 2000/2002 drawing:
\begin{verbatim}
DL_Dxf dxf;
DL_Codes::version exportVersion = DL_Codes::AC1015;
DL_WriterA* dw = dxf.out("myfile.dxf", exportVersion);
if (dw==NULL) {
    printf("Cannot open file 'myfile.dxf' \
            for writing.");
    // abort function e.g. with return
}
\end{verbatim}


\begin{verbatim}
// int variable:
dw->dxfString(9, "$INSUNITS");
dw->dxfInt(70, 4);
// real (double, float) variable:
dw->dxfString(9, "$DIMEXE");
dw->dxfReal(40, 1.25);
// string variable:
dw->dxfString(9, "$TEXTSTYLE");
dw->dxfString(7, "Standard");
// vector variable:
dw->dxfString(9, "$LIMMIN");
dw->dxfReal(10, 0.0);
dw->dxfReal(20, 0.0);
\end{verbatim}

\subsubsection*{Closing the Header}
Use the following code to close the DXF header (end the current section):
\begin{verbatim}
dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Tables Section}
\subsubsection*{Opening the Tables Section}
The tables section of a DXF file contains some tables defining viewports, linestyles, layers, etc.
Open the tables section with the function:
\begin{verbatim}
dw->sectionTables();
\end{verbatim}

\subsubsection*{Writing the Viewports}
Viewports are not directly supported by dxflib. However, they still need to be there in a valid DXF file. You can write the standard viewports using the function:
\begin{verbatim}
dxf.writeVPort(*dw);
\end{verbatim}

\subsubsection*{Writing the Linetypes}
Only linetypes that are actually used need to be defined in the DXF file. For simplification, you might want to store all linetypes supported by dxflib as shown below.
\begin{verbatim}
dw->tableLineTypes(25);
dxf.writeLineType(*dw, DL_LineTypeData("BYBLOCK", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BYLAYER", 0));
dxf.writeLineType(*dw,
    DL_LineTypeData("CONTINUOUS", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO02W100", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO03W100", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO04W100", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO05W100", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BORDER", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BORDER2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BORDERX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("CENTER", 0));
dxf.writeLineType(*dw, DL_LineTypeData("CENTER2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("CENTERX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHDOT", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHDOT2", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("DASHDOTX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHED", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHED2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHEDX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DIVIDE", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DIVIDE2", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("DIVIDEX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DOT", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DOT2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DOTX2", 0));
dw->tableEnd();
\end{verbatim}



\subsubsection*{Writing the Layers}
Layers are a substantial part of most DXF drawings. All layers that are used in the drawing need to be defined in this table section. The following example code writes three layers with names "0", "mainlayer" and "anotherlayer" to the DXF file. Note that before writing the layers, you need to specify how many layers there are in total. Layer "0" is the default layer. It cannot be omitted.

\begin{verbatim}
int numberOfLayers = 3;
dw->tableLayers(numberOfLayers);

dxf.writeLayer(*dw, 
    DL_LayerData("0", 0), 
    DL_Attributes(
        std::string(""),      // leave empty
        DL_Codes::black,      // default color
        100,                  // default width
        "CONTINUOUS"));       // default line style

dxf.writeLayer(*dw, 
    DL_LayerData("mainlayer", 0), 
    DL_Attributes(
        std::string(""),
        DL_Codes::red,
        100,
        "CONTINUOUS"));

dxf.writeLayer(*dw, 
    DL_LayerData("anotherlayer", 0), 
    DL_Attributes(
        std::string(""),
        DL_Codes::black,
        100,
        "CONTINUOUS"));

dw->tableEnd();
\end{verbatim}

The default line width is given in 1/100mm. The color enum in namespace DL\_Codes defines the most common colors.
Writing Various Other Tables
These tables are also needed. For more information, please refer to the DXF documentation [DXF].
\begin{verbatim}
dxf.writeStyle(*dw);
dxf.writeView(*dw);
dxf.writeUcs(*dw);

dw->tableAppid(1);
dw->tableAppidEntry(0x12);
dw->dxfString(2, "ACAD");
dw->dxfInt(70, 0);
dw->tableEnd();

Writing Dimension Styles
Dimension Styles define the look of dimensions.
dxf.writeDimStyle(*dw, 
    arrowSize, 
    extensionLineExtension, 
    extensionLineOffset, 
    dimensionGap, 
    dimensionTextSize);
\end{verbatim}

\subsubsection*{Writing Block Records}
Block records define the names of available blocks in the DXF file. The following example declares the existence of two blocks with names "myblock1" and "myblock2". Note that the first call is also needed. It opens the blocks table and writes some standard blocks that might be required by the DXF version.
\begin{verbatim}
dxf.writeBlockRecord(*dw);
dxf.writeBlockRecord(*dw, "myblock1");
dxf.writeBlockRecord(*dw, "myblock2");
dw->tableEnd();
\end{verbatim}



\subsubsection*{Ending the Tables Section}

\begin{verbatim}
dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Blocks Section}
The blocks section defines the entities of each block.

\begin{verbatim}
dw->sectionBlocks();

dxf.writeBlock(*dw, 
    DL_BlockData("*Model_Space", 0, 0.0, 0.0, 0.0));
dxf.writeEndBlock(*dw, "*Model_Space");

dxf.writeBlock(*dw, 
    DL_BlockData("*Paper_Space", 0, 0.0, 0.0, 0.0));
dxf.writeEndBlock(*dw, "*Paper_Space");

dxf.writeBlock(*dw, 
    DL_BlockData("*Paper_Space0", 0, 0.0, 0.0, 0.0));
dxf.writeEndBlock(*dw, "*Paper_Space0");

dxf.writeBlock(*dw,
    DL_BlockData("myblock1", 0, 0.0, 0.0, 0.0));
// ...
// write block entities e.g. with dxf.writeLine(), ..
// ...
dxf.writeEndBlock(*dw, "myblock1");

dxf.writeBlock(*dw,
    DL_BlockData("myblock2", 0, 0.0, 0.0, 0.0));
// ...
// write block entities e.g. with dxf.writeLine(), ..
// ...
dxf.writeEndBlock(*dw, "myblock2");

dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Entities Section}
The entities section defines the entities of the drawing. The two entities in the following example use the attributes of their layer (256 = color by layer, -1 = line width by layer, "BYLAYER" = line style by layer).




\begin{verbatim}
dw->sectionEntities();

// write all your entities..
dxf.writePoint(
    *dw,
    DL_PointData(10.0,
                 45.0,
                  0.0),
    DL_Attributes("mainlayer", 256, -1, "BYLAYER"));

dxf.writeLine(
    *dw,
    DL_LineData(25.0,   // start point
                30.0,
                 0.0,
               100.0,   // end point
               120.0,
                 0.0),
    DL_Attributes("mainlayer", 256, -1, "BYLAYER"));

dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Objects Section}
\begin{verbatim}
dxf.writeObjects(*dw);
dxf.writeObjectsEnd(*dw);
\end{verbatim}
\subsubsection{Ending and Closing the File}
\begin{verbatim}
dw->dxfEOF();
dw->close();
delete dw;
\end{verbatim}

\subsection{libdxfrw}
\noindent libdxfrw is a free C++ library to read and write DXF files in both formats, ascii and binary form. It is licensed under the terms of the GNU General Public License version 2 (or at you option any later version).
\subsubsection*{Building and installing the library}
\begin{verbatim}
mkdir build
cd build
cmake ..
make
sudo make install
\end{verbatim}
\subsubsection*{For non-debug version}
\begin{verbatim}
mkdir release
cd release
cmake -DCMAKE_BUILD_TYPE=Release ..
make
sudo make install
\end{verbatim}
\subsubsection*{For UBUNTU/Mint Folks}
\begin{verbatim}
mkdir release
cd release
cmake - DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX:PATH=/usr .. && make all
make
sudo make install
\end{verbatim}

\subsection{What is Git?}
Git is a distributed revision control and source code management (SCM) system with an emphasis on speed, data integrity, and support for distributed, non-linear workows. Git was initially designed and developed by Linus Torvalds for Linux  kernel development in 2005,  and has  since become the most widely adopted version   control   system  for software development.

Version control is the only reasonable way to keep track of changes in code, manuscripts, presentations, and data analysis projects. I used to make numbered tar.gz files for a project. But exploring the differences is difficult, to say the least. And if you use git properly, you’ll have annotated each small change.

Merging collaborators’ changes made easy. Have you ever had to deal with a collaborator sending you modifications distributed across many files, or had to deal with two people having made changes to the same file at the same time? Painful. git merge is the answer.

GitHub is essentially the place where you store the code that tells the baker how to make cookies. It is the best place to share code with friends, co-workers, classmates, and total strangers. But to really understand GitHub, you need to understand what a “git” is.

At the heart of GitHub is Git, an open source project started by Linux creator Linus Torvalds. Matthew McCullough, a trainer at GitHub, explains that Git, like other version control systems, manages and stores revisions of projects. Although it’s mostly used for code, McCullough says Git could be used to manage any other type of file, such as Word documents or Final Cut projects. Think of it as a filing system for every draft of a document. Some of Git’s predecessors, such as CVS and Subversion, have a central “repository” of all the files associated with a project. McCullough explains that when a developer makes changes, those changes are made directly to the central repository. With distributed version control systems like Git, if you want to make a change to a project you copy the whole repository to your own system. You make your changes on your local copy, then you “check in” the changes to the central server. McCullough says this encourages the sharing of more granular changes since you don’t have to connect to the server every time you make a change.

So, what is Git in a nutshell? This is an important section to absorb, because if you understand what Git is and the fundamentals of how it works, then using Git effectively will probably be much easier for you. As you learn Git, try to clear your mind of the things you may know about other VCSs, such as Subversion and Perforce; doing so will help you avoid subtle confusion when using the tool. Git stores and thinks about information much differently than these other systems, even though the user interface is fairly similar, and understanding those differences will help prevent you from becoming confused while using it.

A “git” is a version control system. This system means that when you, the developer, create something and make changes to the code or release new versions, you’ll be able to keep track of all the modifications in a central repository. It can even track of of revisions others make so you save changes and improvements after collaborating. Developers can download a new version of the software, make changes, and upload the newest revision. And everyone can see these new changes, download them, and contribute.

By far, the most widely used modern version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments). 

Having a distributed architecture, Git is an example of a DVCS (hence Distributed Version Control System). Rather than have only one single place for the full version history of the software as is common in once-popular version control systems like CVS or Subversion (also known as SVN), in Git, every developer's working copy of the code is also a repository that can contain the full history of all changes. In addition to being distributed, Git has been designed with performance, security and flexibility in mind.

As with most other distributed revision control systems, and unlike most clientserver systems, every Git working directory is a full-edged repository with complete history and full version- tracking capabilities, independent of network access or a central server. Like the Linux kernel, Git is free and open source software distributed under the terms of the GNU General Public License version 2 to handle everything from small to very large projects with speed and efficiency.
Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workows.

\begin{itemize}
	\item \textbf{Installation of Git}

Installation of git is a very easy process.
The current git version is: 2.0.4.
Type the commands in the terminal:\\\\
\emph{
	\$ sudo apt-get update\\\\
	\$ sudo apt-get install git\\\\}
This will install the git on your pc or laptop.

\item \textbf{Various Git Commands}

Git is the open source distributed version control system that facilitates GitHub activities on your laptop or desktop. The commonly used Git command line instructions are:-\\

\item \textbf{Create Repositories}
\addcontentsline{toc}{subsection}{Create Repositories}
Start a new repository or obtain from an exiting URL

\begin{description}
	
	\item [\$ git init [ project-name]]\\
	Creates a new local repository with the specified name
	\item [\$ git clone [url]]\\
	Downloads a project and its entire version history
	
\end{description}


\item \textbf{Make Changes}
\addcontentsline{toc}{subsection}{Make Changes}
Review edits and craft a commit transaction

\begin{description}
	
	\item [\$ git status] \leavevmode \\
	Lists all new or modified files to be committed
	
	\item [\$ git diff] \leavevmode \\
	Shows file differences not yet staged
	
	\item [\$ git add [file]]\\
	Snapshots the file in preparation for versioning
	
	\item [\$ git reset [file]]\\
	Unstages the file, but preserve its contents
	
	\item [\$ git commit -m "[descriptive message]"]\\
	Records file snapshots permanently in version history
	
\end{description}

\end{itemize}

\subsection{Introduction to GitHub}
\noindent GitHub is a Git repository web-based hosting service which offers all of the functionality of Git as well as adding many of its own features. Unlike Git which is strictly a command-line tool, Github provides a web-based graphical interface and desktop as well as mobile integration. It also provides access control and several collaboration features such as wikis, task management, and bug tracking and feature requests for every project.\\

\noindent GitHub offers both paid plans for private repto handle everything from small to very large projects with speed and efficiency. ositories, and free accounts, which are usually used to host open source software projects. As of 2014, Github reports having over 3.4 million users, making it the largest code host in the world.\\

\noindent GitHub has become such a staple amongst the open-source development community that many developers have begun considering it a replacement for a conventional resume and some employers require applications to provide a link to and have an active contributing GitHub account in order to qualify for a job.

\subsection{Introduction to GitLab}
What is GitLab? GitLab is an online Git repository manager with a wiki, issue tracking, CI and CD. It is a great way to manage git repositories on a centralized server. GitLab gives you complete control over your repositories or projects and allows you to decide whether they are public or private for free.

\subsubsection{GitLab.com}
\begin{itemize}
	\item GitLab.com hosts your (private) software projects for free.
	\item It offers free public and private repositories, issue-tracking and wikis.
	\item It runs GitLab Enterprise Edition and GitLab CI.
	\item No installation required, you can just sign up for a free account. Support Package:
	\item Free subscribers can use the GitLab.com Support Forum if they have questions.
	\item GitLab.com Bronze Support will let you email support directly for timely, personal and private answers. This costs \$9.99 per user per year for next-business-day response time and is available in packs of 20 users.
\end{itemize}

\subsubsection{GitLab Community Edition (CE)}
\begin{itemize}
	\item Free, self hosted application where you can get support from the Community
	\item Feature rich: Git repository management, code reviews, issue tracking, activity feeds and wikis. It comes with GitLab CI for continuous integration and delivery.
	\item Open Source: MIT licensed, community driven, 700+ contributors, inspect and modify the source, easy to integrate into your infrastructure.
	\item Scalable: support 25,000 users on one server or a highly available active/active cluster.
	\item Merge requests with line-by-line comments, CI and issue tracker integrations.
\end{itemize}

\subsubsection{GitLab Enterprise Edition (EE)}
\begin{itemize}
	\item Self hosted application that comes with additional support.
	\item Builds on top of the Community Edition and includes extra features mainly aimed at organizations with more than 100 users.
	\item It has LDAP group sync, audit logs and multiple roles.
	\item It includes deeper authentication and authorization integration, has fine-grained workflow management, has extra server management options and it integrates with your tool stack.
	\item GitLab EE runs on your servers.
\end{itemize}

\subsubsection{GitLab Continuous Integration (CI)}
\begin{itemize}
	\item Free, self hosted application that integrates with GitLab CE/EE. Also availble as SaaS at ci.gitlab.com.
	\item Easy to set up since it is included in Omnibus packages of GitLab or use it for free on ci.gitlab.com.
	\item Beautiful interface with a clear menu structure.
	\item Performant and stable, as tests run distributed on separate machines.
	\item Will help you receive test results faster with each commit running in parallel on multiple jobs.
	\item Free to use and completely open source. All CI code is MIT licensed.
\end{itemize}



\subsection{FreeCAD}
FreeCAD is a general purpose feature-based, parametric 3D modeler for CAD, MCAD, CAx, CAE and PLM, aimed directly at mechanical engineering and product design but also fits a wider range of uses in engineering, such as architecture or other engineering specialties. It is 100\% Open Source (LGPL2+ license) and extremely modular, allowing for very advanced extension and customization.

FreeCAD is based on OpenCasCade, a powerful geometry kernel, features an Open Inventor-compliant 3D scene representation model provided by the Coin 3D library, and a broad Python API. The interface is built with Qt. FreeCAD runs exactly the same way on Windows, Mac OSX, BSD and Linux platforms.

Home page: http://www.freecadweb.org

Documentation wiki: http://www.freecadweb.org/wiki

Forum: http://forum.freecadweb.org

Bug tracker: http://www.freecadweb.org/tracker

Git repository: https://github.com/FreeCAD/FreeCAD

\subsubsection{Installing}

Precompiled (installable) packages are available for Windows and Mac on the releases page at https://github.com/FreeCAD/FreeCAD/releases

On most Linux distributions, FreeCAD is directly installable from the software center application.

Other options are described at http://www.freecadweb.org/wiki/index.php?title=Download

\subsubsection{Install on Unix}
The installation of FreeCAD on the most well-known linux systems has been now endorsed by the community, and FreeCAD should be directly available via the package manager available on your distribution. The FreeCAD team also provides a couple of "official" packages when new releases are made, and a couple of experimental PPA repositories for testing bleeding-edge features.

\begin{itemize}
\item
\textbf{Ubuntu and Ubuntu-based systems}

Many Linux distributions are based on Ubuntu and share its repositories. Besides official variants (Kubuntu, Lubuntu and Xubuntu), there are non official distros such as Linux Mint, Voyager and others. The installation options below should be compatible to these systems.

\item 
\textbf{Official Ubuntu repository}

FreeCAD is available from Ubuntu repositories and can be installed via the Software Center or with this command in a terminal:

\begin{verbatim}
sudo apt-get install freecad
\end{verbatim}

\item
\textbf{Debian and other debian-based systems}

Since Debian Lenny, FreeCAD is available directly from the Debian software repositories and can be installed via synaptic or simply with:

\begin{verbatim}
sudo apt-get install freecad
\end{verbatim}

\item
\textbf{OpenSUSE}

FreeCAD is typically installed with:

\begin{verbatim}
zypper install FreeCAD
\end{verbatim}

\item
\textbf{Gentoo}

FreeCAD can be built/installed simply by issuing:

\begin{verbatim}
emerge freecad
\end{verbatim}

\item
\textbf{Compile from source}

On recent linux distributions, FreeCAD is generally easy to build, since all dependencies are usually provided by the package manager. It basically involves 3 steps:

\begin{itemize}
\item Getting the FreeCAD source code
\item Getting the dependencies (packages FreeCAD depends upon)
\item Configure with "cmake" and Compile with "make"
\end{itemize}

Below, you'll find detailed explanations of the whole process and particularities you might encounter. If you find anything wrong or out-of-date in the text below (Linux distributions change often), or if you use a distribution which is not listed, please help us correcting it.

\item
\textbf{Getting the source}

Before you can compile FreeCAD, you need the source code. There are 3 ways to get it:

\item 
\textbf{Git}

The quickest and best way to get the code is to clone the read-only git repository now hosted on GitHub (you need the git package installed):

\begin{verbatim}
git clone https://github.com/FreeCAD/FreeCAD.git free-cad-code
\end{verbatim}

This will place a copy of the latest version of the FreeCAD source code in a new directory called "free-cad-code".

\item
\textbf{Github}

The official FreeCAD repository is on Github: github.com/FreeCAD/FreeCAD

\item
\textbf{Source package}

Alternatively you can download a source package, but they could be already quite old so it's always better to get the latest sources via git or github.

Official FreeCAD source packages (distribution-independent): to be advised
Getting the dependencies

To compile FreeCAD under Linux you have to install all libraries mentioned in Third Party Libraries first. Please note that the names and availability of the libraries will depend on your distribution. Note that if you don't use the most recent version of your distribution, some of the packages below might be missing from your repositories. In that case, look in the Older and non-conventional distributions section below.

\item 
\textbf{Getting the dependencies}

To compile FreeCAD under Linux you have to install all libraries mentioned in Third Party Libraries first. Please note that the names and availability of the libraries will depend on your distribution. Note that if you don't use the most recent version of your distribution, some of the packages below might be missing from your repositories. In that case, look in the Older and non-conventional distributions section below.

\item
\textbf{Debian and Ubuntu}

On Debian-based systems (Debian, Ubuntu, Mint, etc...) it is quite easy to get all needed dependencies installed. Most of the libraries are available via apt-get or synaptic package manager.

\begin{verbatim}
build-essential
cmake
python
python-matplotlib
libtool
either:

libcoin60-dev (Debian Wheezy, Wheezy-backports, Ubuntu 13.04 and before)
or:

libcoin80-dev (Debian unstable(Jesse), testing, Ubuntu 13.10 and forward)
libsoqt4-dev
libxerces-c-dev
libboost-dev
libboost-filesystem-dev
libboost-regex-dev
libboost-program-options-dev
libboost-signals-dev
libboost-thread-dev
libboost-python-dev
libqt4-dev
libqt4-opengl-dev
qt4-dev-tools
python-dev
python-pyside
pyside-tools
either:

libopencascade-dev (official opencascade version)
or:

liboce*-dev (opencascade community edition)
oce-draw
libeigen3-dev
libqtwebkit-dev
libshiboken-dev
libpyside-dev
libode-dev
swig
libzipios++-dev
libfreetype6
libfreetype6-dev
\end{verbatim}

Additional instruction for libcoin80-dev Debian wheezy-backports, unstable, testing, Ubuntu 13.10 and forward

Note that liboce*-dev includes the following libraries:
\begin{verbatim}
liboce-foundation-dev
liboce-modeling-dev
liboce-ocaf-dev
liboce-visualization-dev
liboce-ocaf-lite-dev
\end{verbatim}

You may have to install these packages by individual name.

Optionally you can also install these extra packages:


\texttt{libsimage-dev} (to make Coin to support additional image file formats)\\
\texttt{checkinstall} (to register your installed files into your system's package manager, so yo can easily uninstall later)\\
\texttt{python-pivy} (needed for the 2D Drafting module)\\
\texttt{python-qt4} (needed for the 2D Drafting module)\\
\texttt{doxygen and libcoin60-doc} (if you intend to generate source code documentation)\\
\texttt{libspnav-dev} (for 3Dconnexion devices support like the Space Navigator or Space Pilot)


\item
\textbf{Compile FreeCAD}

\begin{itemize}
\item
\textbf{Using cMake}

cMake is a newer build system which has the big advantage of being common for different target systems (Linux, Windows, MacOSX, etc). FreeCAD is now using the cMake system as its main building system. Compiling with cMake is usually very simple and happens in 2 steps. In the first step, cMake checks that every needed programs and libraries are present on your system and sets up all that's necessary for the subsequent compilation. You are given a few alternatives detailed below, but FreeCAD comes with sensible defaults. The second step is the compiling itself, which produces the FreeCAD executable. Changing any options for cmake away from their default values, is much easier with cmake-gui or other graphical cmake applications than with cmake on the command line, as the graphical applications will give you interactive feed back.

Since FreeCAD is a heavy application, compiling can take a bit of time (about 10 minutes on a fast machine, 30 minutes (or more) on a slow one)

\item
\textbf{In-source building}

If you are unsure then, due to its limitations, do not make an in-source build, create an out-of-source build as explained in the next section. However FreeCAD can be built in-source, which means that all the files resulting from the compilation stay in the same folder as the source code. This is fine if you are just looking at FreeCAD, and want to be able to remove it easily by just deleting that folder. But in case you are planning to compile it often, you are advised to make an out-of-source build, which offers many more advantages. The following commands will compile FreeCAD:

\texttt{\$ cd freecad} (the folder where you cloned the freecad source)

If you want to use your system's copy of Pivy, which you most commonly will, then if not on Linux, set the compiler flag to use the correct pivy (via FREECAD\_USE\_EXTERNAL\_PIVY=1). Using external Pivy became the default for Linux, during development of FreeCAD 0.16, so it does not need to be manually set when compiling this version onwards, on Linux. Also, set the build type to Debug if you want a debug build or Release if not. A Release build will run much faster than a Debug build. Sketcher becomes very slow with complex sketches if your FreeCAD is a Debug build. (NOTE: the space and "." after the cmake flags are CRITICAL!):

\item
\textbf{For a Debug build}

\begin{verbatim}
$ cmake -DFREECAD_USE_EXTERNAL_PIVY=1 -DCMAKE_BUILD_TYPE=Debug .
$ make
\end{verbatim}
Or for a Release build

\begin{verbatim}
$ cmake -DFREECAD_USE_EXTERNAL_PIVY=1 -DCMAKE_BUILD_TYPE=Release .
$ make
\end{verbatim}

Your FreeCAD executable will then reside in the "bin" folder, and you can launch it with:

\begin{verbatim}
$ ./bin/FreeCAD
\end{verbatim}




How to repair your source code directory after accidentally running an in-source build.

This is a method, using Git, to repair your source code directory after accidentally running an in-source build.

\begin{itemize}
\item delete everything in your source base directory EXCEPT the hidden .git folder
\item In terminal 'git reset --hard HEAD'
//any remnants of an 'in source' build will be gone.
\item delete everything from your 'out of source' build directory and start over again with cmake and a full new clean build.
\end{itemize}

\item 
\textbf{Out-of-source build}

If you intend to follow the fast evolution of FreeCAD, building in a separate folder is much more convenient. Every time you update the source code, cMake will then intelligently distinguish which files have changed, and recompile only what is needed. Out-of-source builds are specially handy when using the Git system, because you can easily try other branches without confusing the build system. To build out-of-source, simply create a build directory, distinct from your FreeCAD source folder, and, from the build folder, point cMake (or if using cmake-gui replace "cmake" in the code below with "cmake-gui") to the source folder:

\begin{verbatim}
mkdir freecad-build
cd freecad-build
cmake ../freecad (or whatever the path is to your FreeCAD source folder)
make
\end{verbatim}

The FreeCAD executable will then reside in the "bin" directory (within your freecad-build directory).

\item
\textbf{Configuration options}

There are a number of experimental or unfinished modules you may have to build if you want to work on them. To do so, you need to set the proper options for the configuration phase. Do it either on the command line, passing -D <var>:<type>=<value> options to cMake or using one of the availables gui-frontends (eg for Debian, packages cmake-qt-gui or cmake-curses-gui). Changing any options for cmake away from their default values, is much easier with cmake-gui or other graphical cmake applications than with cmake on the command line, as they will give you interactive feed back.

As an example, to configure FreeCAD with the Assembly module built just tick the box in a cmake gui application (e.g. cmake-gui) or on the command line issue:

\begin{verbatim}
cmake -D FREECAD_BUILD_ASSEMBLY:BOOL=ON ''path-to-freecad-root''
\end{verbatim}

Possible options are listed in FreeCAD's root CmakeLists.txt file.

\item
\textbf{Qt designer plugin}

If you want to develop Qt stuff for FreeCAD, you'll need the Qt Designer plugin that provides all custom widgets of FreeCAD. Go to

\texttt{freecad/src/Tools/plugins/widget}
So far we don't provide a makefile -- but calling

\texttt{qmake plugin.pro}
creates it. Once that's done, calling

\texttt{make}
will create the library libFreeCAD\_widgets.so. To make this library known to Qt Designer you have to copy the file to \$QTDIR\/plugin\/designer

\item
\textbf{Doxygen}

If you feel bold enough to dive in the code, you could take advantage to build and consult Doxygen generated FreeCAD's Source documentation.


\end{itemize}
\end{itemize}

\subsection{Introduction to \LaTeX}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.2]{images/latex.png}
\caption{\LaTeX{} Logo}
\end{figure}
\hspace{-1.8em} \LaTeX{}, I had never heard about this term before doing this project,
but when I came to know about it's features, it is just excellent. 
\LaTeX (pronounced /ˈleɪtɛk/, /ˈleɪtɛx/, /ˈlɑːtɛx/, or /ˈlɑːtɛk/) is a 
document markup language and document preparation system for the \TeX{} 
typesetting  program. Within the typesetting system, its name is styled 
as \LaTeX.
\begin{figure}[ht]
\centering
\includegraphics[scale=0.4]{images/donald.jpg}
\caption{Donald Knuth, Inventor Of \TeX{} typesetting system}
\end{figure}

\hspace{-1.8em} Within the typesetting system, its name is styled as \LaTeX. The term 
\LaTeX{} refers only to the language in which documents are written, 
not to the editor used to write those documents. In order to create a 
document in \LaTeX, a .tex file must be created using some form of text 
editor. While most text editors can be used to create a \LaTeX{} document, 
a number of editors have been created specifically for working with \LaTeX.\\

\noindent\LaTeX{} is most widely used by mathematicians, scientists, 
engineers, philosophers, linguists, economists and other scholars in 
academia. As a primary or intermediate format, e.g., translating DocBook 
and other XML-based formats to PDF, \LaTeX{} is used because of the 
high quality of typesetting achievable by \TeX. The typesetting system 
offers programmable desktop publishing features and extensive facilities 
for automating most aspects of typesetting and desktop publishing, 
including numbering and cross-referencing, tables and figures, 
page layout and bibliographies.\\

\noindent\LaTeX{} is intended to provide a high-level language that
accesses the power of \TeX. \LaTeX{} essentially comprises a
collection of \TeX{} macros and a program to process \LaTeX documents. 
Because the \TeX{} formatting commands are very low-level, it is usually 
much simpler for end-users to use \LaTeX{}.


\subsubsection{Typesetting}
\LaTeX{} is based on the idea that authors should be able to focus on 
the content of what they are writing without being distracted by its 
visual presentation. in preparing a \LaTeX{} document, the author 
specifies the logical structure using familiar concepts such as 
chapter, section, table, figure, etc., and lets the \LaTeX{} system 
worry about the presentation of these structures. it therefore 
encourages the separation of layout from content while still allowing 
manual typesetting adjustments where needed. 

\begin{verbatim}
\documentclass[12pt]{article}
\usepackage{amsmath}
\title{\LaTeX}
\begin{document}
  \maketitle 
  \LaTeX{} is a document preparation system 
  for the \TeX{} typesetting program.
   \par 
   $E=mc^2$
\end{document}
\end{verbatim}

\subsubsection{Installing \LaTeX{} on System}
Installation of \LaTeX{} on personal system is quite easy. As i have used \LaTeX{} on Ubuntu 13.04 so i am discussing the installation steps for Ubuntu 13.04 here:
\begin{itemize}
\item Go to terminal and type\\\\
\textit{sudo apt-get install texlive-full}
\item Your Latex will be installed on your system and you can check for manual page by typing.\\\\
\textit{man latex}\\

in terminal which gives manual for latex command.
\item To do very next step now one should stick this to mind that the document which one is going to produce is written in any type of editor whether it may be your most common usable editor Gedit or you can use vim by installing first vim into your system using command.\\\\
\textit{sudo apt-get install vim}
\item After you have written your document it is to be embedded with some set of commands that Latex uses so as to give a structure to your document. Note that whenever you wish your document to be looked into some other style just change these set of commands.
\item When you have done all these things save your piece of code with .tex format say test.tex. Go to terminal and type\\\\
\textit{latex path of the file test.tex Or pdflatex path of the file test.tex\\ eg: pdflatex test.tex}\\
for producing pdf file simultaneously.\\
After compiling it type command\\\\
\textit{evince filename.pdf\\ eg: evince test.pdf}\\
To see output pdf file. 
\end{itemize}

\subsubsection{Making Graphics in \LaTeX{}}
\LaTeX{} s also know popularly for making complex graphics. One such example is shown below here:\\
\begin{verbatim}
\documentclass{article}
\usepackage{tikz}
\usetikzlibrary{calendar,shadings}
\renewcommand*{\familydefault}{\sfdefault}
\colorlet{winter}{blue}
\colorlet{spring}{green!60!black}
\colorlet{summer}{orange}
\colorlet{fall}{red}
\newcount\mycount
\begin{document}
\begin{tikzpicture}[transform shape,
every day/.style={anchor=mid,font=\tiny}]
\node[circle,shading=radial,outer color=blue!30,inner color=white,
minimum width=15cm] {\textcolor{blue!80!black}{\Huge\the\year}};
\foreach \month/\monthcolor in
{1/winter,2/winter,3/spring,4/spring,5/spring,6/summer,
7/summer,8/summer,9/fall,10/fall,11/fall,12/winter} {
\mycount=\month
\advance\mycount by -1
\multiply\mycount by 30
\advance\mycount by -90
\shadedraw[shading=radial,outer color=\monthcolor!30,middle color=white,
inner color=white,draw=none] (\the\mycount:5.4cm) circle(1.4cm);
\calendar at (\the\mycount:5.4cm) [
dates=\the\year-\month-01 to \the\year-\month-last]
if (day of month=1) {\large\color{\monthcolor!50!black}\tikzmonthcode}
if (Sunday) [red]
if (all) {
\mycount=1
\advance\mycount by -\pgfcalendarcurrentday
\multiply\mycount by 11
\advance\mycount by 90
\pgftransformshift{\pgfpointpolar{\mycount}{1.2cm}}};}
\end{tikzpicture}
\end{document}
\end{verbatim}\\
%\begin{figure}[ht]
%\centering
%\includegraphics[scale=0.4]{images/3d.png}
%\caption{Graphics in \LaTeX{}}
%\end{figure}
\LaTeX{} with just invoking few additional packages.

\subsubsection{Pdfscreen \LaTeX{}}
There are some packages that can help to have unified document using \LaTeX{}. Example of such a package is pdfscreen that let the user view it’s document in two forms-print and screen. Print for hard copy and screen for viewing your document on screen. Download this package from www.ctan.org/tex-archive/macros/latex/contrib/pdfscreen/.\\
Then install it using above mention method.\\

\noindent To test it the test code is given below:-\\
Just changing print to screen gives an entirely different view. But for working of pdfscreen another package required are comment and fancybox.\\

\noindent The fancybox package provides several different styles of boxes for framing and rotating content in your document. Fancybox provides commands that produce square-cornered boxes with single or double lines, boxes with shadows, and round-cornered boxes with normal or bold lines. You can box mathematics, floats, center, flushleft, and flushright, lists, and pages.\\
 	
\noindent Whereas comments package selectively include/excludes portions of text. The comment package allows you to declare areas of a document to be included or excluded. One need to make these declarations in the preamble of your file. The package uses a method for exclusion that is pretty robust, and can cope with ill-formed bunches of text.\\

\noindent So these extra packages needed to be installed on system for the proper working of pdfscreen package.
\subsubsection{Web based graphic generation using \LaTeX{}}
\LaTeX{} is also useful when there is need of generating the graphics from browser. For
example to draw a circle by just entering its radius in html input box. So this kind
A
of project can be conveniently handled using \LaTeX{}. Basic idea behind this generation
process is that when user clicks on submit button after entering radius a script will run
that enter the radius in already made .tex file and recompiles it on server and makes its
pdf and postscript file. After that user can view those files by clicking on link provided
to view the files. See some screen shots of such a graphic generation project made by
Dr. H.S. Rai:\\
So here in the above input page which is also the index page user can enter input
for length of rectangle, breadth of rectangle and for radius of circle after that user can submit the values. After the values get submitted a script get runs by php code at server
side. This script first enters the dimensions of rectangle and circle that were selected by
user in to an already existing .tex file and replace with the older dimensions there. After
that script recompiles the the tex file and make it available for user.\\
	
\noindent In above figure it gets clear that .tex file has been compiled and pdf and postscript files
are available to user and user can download the graphics so produced. Hence graphics
can be generated in \LaTeX{} through web interface.

\subsection{Doxygen}
\begin{figure}[h]
	\centering \includegraphics[scale=1]{images/doxygen.jpg}
\end{figure}
Doxygen is a documentation generator, a tool for writing software reference documentation. The documentation is written within code, and is thus relatively easy to keep up to date. Doxygen can cross reference documentation and code, so that the reader of a document can easily refer to the actual code.
Doxygen supports multiple programming languages, especially C++, C, C\#, Objective-C, Java, Python, IDL, VHDL, Fortran and PHP.[2] Doxygen is free software, released under the terms of the GNU General Public License.

Doxygen is the de facto standard tool for generating documentation from annotated C++ sources, but it also supports other popular programming languages such as C, Objective-C, C\#, PHP, Java, Python, IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL, Tcl, and to some extent.
Doxygen can help you in three ways:

\begin{itemize}
	\item It can generate an on-line documentation browser (in HTML) and/or an off-line reference manual (in ) from a set of documented source files. There is also support for generating output in RTF (MS-Word), PostScript, hyperlinked PDF, compressed HTML, and Unix man pages. The documentation is extracted directly from the sources, which makes it much easier to keep the documentation consistent with the source code.
	\item You can configure doxygen to extract the code structure from undocumented source files. This is very useful to quickly find your way in large source distributions. Doxygen can also visualize the relations between the various elements by means of include dependency graphs, inheritance diagrams, and collaboration diagrams, which are all generated automatically.
	\item You can also use doxygen for creating normal documentation (as I did for the doxygen user manual and web-site).
\end{itemize}

Doxygen looks at the file’s extension to determine how to parse a file. If a file has an .idl or .odl extension it is treated as an IDL file. If it has a .java extension it is treated as a file written in Java. Files ending with .cs are treated as C\# files and the .py extension selects the Python parser. Finally, files with the extensions .php, .php4, .inc or .phtml are treated as PHP sources. Any other extension is parsed as if it is a C/C++ file, where files that end with .m are treated as Objective-C source files.

If you start using doxygen for an existing project (thus without any documentation that doxygen is aware of), you can still get an idea of what the structure is and how the documented result would look like. To do so, you must set the EXTRACT ALL tag in the configuration file to YES. Then, doxygen will pretend everything in your sources is documented. Please note that as a consequence warnings about undocumented members will not be generated as long as EXTRACT ALL is set to YES.

To analyse an existing piece of software it is useful to cross-reference a (documented) entity with its definition in the source files. Doxygen will generate such cross-references if you set the SOURCE BROWSER tag to YES. It can also include the sources directly into the documentation by setting INLINE SOURCES to YES (this can be handy for code reviews for instance).

Doxygen is developed under Mac OS X and Linux, but is set-up to be highly portable. As a result, it runs on most other Unix flavors as well. Furthermore, executables for Windows are available.

\subsubsection{Features of Doxygen}
\begin{itemize}
	\item Requires very little overhead from the writer of the documentation. 
	Plain text will do, Markdown is support, and for more fancy or structured 
	output HTML tags and/or some of doxygen's special commands can be used.
	\item Cross platform: Works on Windows and many Unix flavors (including 
	Linux and Mac OS X).
	\item Comes with a GUI frontend (Doxywizard) to ease editing the options 
	and run doxygen. The GUI is available on Windows, Linux, and Mac OS X.
	\item Automatically generates class and collaboration diagrams in HTML 
	(as clickable image maps) and $\mbox{\LaTeX}$ (as Encapsulated PostScript 
	images).
	\item Allows grouping of entities in modules and creating a hierarchy 
	of modules.
	\item Doxygen can generate a layout which you can use and edit to change 
	the layout of each page.
	\item Can cope with large projects easily.
\end{itemize}
\subsubsection{Installation of Doxygen}
Doxygen can be installed using following commands:\\

\hspace{4pt} \$ git clone https://github.com/doxygen/doxygen.git\\ 

\hspace{4pt} \$ cd doxygen\\

\hspace{4pt} \$ ./configure\\

\hspace{4pt} \$ make \\
%\newpage

\subsection{GitHub vs. GitLab}
Like GitHub, GitLab is a web-based repository manager that lets teams collaborate on code, duplicate code to safely create and edit new projects, then merge finished code into existing projects. GitLab is written in the Ruby programming language and includes a Wiki and issue-tracking features. It has three separate versions: GitLab Community Edition (CE), Enterprise Edition (EE), and a GitLab-hosted version, GitLab.com. It’s got over 700 contributors and is used by major organizations like Alibaba, NASA, CERN, and more.

Its permissions, branch protection, and authentication features are what really make it stand out. Teams can secure projects on a more granular level, and projects are kept even safer while they’re being worked on, which we cover in more detail below.

\subsubsection{THE GITLAB ADVANTAGE}
	
	GitLab has everything GitHub has, and more—giving teams increased control over their repositories. Its extra features include:
	
	\begin{itemize}
		\item A convenient user interface enables users to access everything from one screen: projects, latest projects, users, latest users, groups, and stats.
		\item Settings allow users to control whether a repository is public or private.
		\item “Snippet support” lets users share small pieces of code from a project, without sharing the whole project.
		\item Protected branches are a new way to keep code safe. They allow users to set higher permissions on a project, so only certain people are able to push, force push, or delete code in a branch.
		\item Authentication levels take this security a step further, allowing users to give people access beyond a read/write level. For example, you can give a team member access to issue tracking without having to give them access to the code itself.
		\item Improved milestones enable you to set milestones at a group level, not just a developer-specific level. Developers can get insight into the whole team’s scope and view the entire project’s milestones, not just their own.
		\item With the “Work in Progress” status, developers can label a project “WIP” to let collaborators know that the code is unfinished. This prevents it from accidentally getting merged with other code before it’s finished.
		\item You can attach files like comments to any communications in GitLab.
	
\end{itemize}


\section{Implementation}
Implementation is the stage of the project where the theoretical design is turned into a working system. It can be considered to be the most crucial stage in achieving a successful new system gaining the users confidence that the new system will work and will be effective and accurate. It is primarily concerned with user training and documentation. Conversion usually takes place about the same time the user is being trained or later. Implementation simply means convening a new system design into operation, which is the process of converting a new revised system design into an operational one.

The new system may be a totally new, replacing an existing manual or automated system or it may be a modification to an existing system. Proper implementation is essential to provide a reliable system to meet organization requirements. The process of putting the developed system in actual use is called system implementation. This includes all those activities that take place to convert from the old system to the new system. The system can be implemented only after through testing is done and if it is found to be working according to the specifications. The system personnel check the feasibility of the system. The more complex the system being implemented, the more involved will be the system analysis and design effort required to implement the three main aspects: education and training, system testing and changeover. 

The implementation state involves the following tasks:
\begin{itemize}
	\item Careful planning.
	\item Investigation of system and constraints.
	\item Design of methods to achieve the changeover.
	\item Training of the staff in the changeover phase.
\end{itemize}

The primary goal of implementation is to write the source code and the internal documentation so that conformance of the code to its specifications can easily be verified and so the debugging, modifications and testing are eased. This goal can be achieved by making the source code as clear and as straightforward as possible. Simplicity, Elegance and Clarity are the hallmarks of good programs whereas complexity are indications of inadequate design and misdirected thinking. The system implementation is a fairly complex and expensive task requiring numerous inter-dependent activities. It involves the effort of a number of groups of people: user and the programmers and the computer operating staff etc. This needs a proper planning to carry out the task successfully.

This project involves the following activities:
\begin{itemize}
	\item Understand the working of the libdxfrw library and have some examples tested.
	\item Add some entities.
	\item Have an input file for the user input.
	\item Use parsing for extraction of information from the input file.
	\item Use the parsed information to create drawings.
\end{itemize}	

The various functions provided by this project, that can be thought of as the features of this project, are listed as follows:

\begin{itemize}
	\item To edit an input file in any text editor.
	\item Run one command and the drawings are created.
	\item No need to waste time creating drawings with mouse clicks (slower methods).
	\item Supports entities upto latest DXF version as per the DXF specifications.
	\item Outputs the DXF file.

\end{itemize}
