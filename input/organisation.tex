\section{Overview}
The drafting work can be automated and accelerated through the use of computer aided design systems. It may be applied for a wide variety of products in the field of automotive electronics, aerospace, naval, architecture, civil and other disciplines of engineering. CAD systems were originally used for automated drafting only. But now they also include three-dimensional modeling and computer simulated operations of the models. Sometimes, CAD is translated as computer assisted drafting, computer aided drafting or a similar phrase. Related acronyms are CADD which stands for Computer Aided design and Drafting, CAID for Computer Aided Industrial design, CAAD for Computer Aided Architectural design. All these terms are essentially synonymous, but there are some subtle differences in meaning and appliation.\\

\noindent CAD is used to design, develop and optimize products, which can be goods used by end consumers or intermediate good used in other products. CAD is also extensively used in the design of tools and equipment required in the manufacturing process, and in the drafting and design and design of all types of buildings, ranging from small residential houses to the largest commercial or Industrial complexes. CAD enables designers to layout and to develop their work on a computer screen, print and save it for future editing, thus saving a lot of time on their drawings. CAD is mainly used for detailed engineering of 3D models and/or 2D drawings of physical components, but it is also used throughout the engineering process, form conceptual design and layout of products to definition of manufacturing methods of components. Rather thatn building prototypes and changing components to determine the effects of tolerance ranges, engineers can use CAD systems to simulate operation to determine loads and stresses. The major benefits of such systems include lower product development costs and a greatly shortened design cycle. The CAD systems running on workstations and mainframe computers are increasingly integrated with computer-aided manufacturing systems.


\section{Introduction To Project} 
\noindent Automated Building Drawing is a project for creating two-dimensional drawings. The main purpose or objective of the project is to make it usable even by the layman. The main target users are the Civil Engineers who want their plans to be printed on the sheets. As of now, they have to create the drawings with the use of paper and pencil. So to automate converting a particular drawing model to the print ready drawings, this project will be beneficial. The interface should be easy
to use and pretty intuitive. Because the interface is a thing that makes user experience better and to make the user use it.
The Drawing module allows you to put your work on computer. That is, to put views of your
models in a 2D window and to insert that window in a drawing, for example a sheet with a border, a wall and a circle and finally print that sheet. 

\section{Software Requirement Analysis}
Software requirement analysis is a process of gathering and interpreting facts, diagnosing problems and the information to recommend improvements on the system. It is a problem solving activity that requires intensive communication between the system users and system developers. System analysis or study is an important phase of any system development process. The system is studied to the minutest detail and analyzed. The system analyst plays the role of the interrogator and dwells deep into the working of the present system. The system is viewed as a whole and the input to the system are identified. The outputs from the organizations are traced to the various processes. System analysis is concerned with becoming aware of the problem, identifying the relevant and decisional variables, analyzing and synthesizing the various factors and determining an optimal or at least a satisfactory solution or program of action.\\

\noindent A detailed study of the process must be made by various techniques like interviews, questionnaires etc. The data collected by these sources must be scrutinized to arrive to a conclusion. The conclusion is an understanding of how the system functions. This system is called the existing system. Now the existing system is subjected to close study and problem areas are identified. The designer now functions as a problem solver and tries to sort out the difficulties that the enterprise faces. The solutions are given as proposals. The proposal is then weighed with the existing system analytically and the best one is selected. The proposal is presented to the user for an endorsement by the user. The proposal is reviewed on user request and suitable changes are made. This is loop that ends as soon as the user is satisfied with proposal.\\

\noindent Preliminary study is the process of gathering and interpreting facts, using the information for further studies on the system. Preliminary study is problem solving activity that requires intensive communication between the system users and system developers. It does various feasibility studies. In these studies a rough figure of the system activities can be obtained, from which the decision about the strategies to be followed for effective system study and analysis can be taken.

\section{User Characteristics}
The objective of  Automated Building Drawings is to give facility to the user to make the drawings of any particular building. User can choose any particular entities from the system. First of all user has to select an entity for example if he wants to draw a wall he has to specify the type of entity to be drawn. Then later the user has to specify the parameters of the entity selected. User can select any of the entities supported by the system and can see the drawing of the same entity as the output on the screen. Also, the system has the feature to save the drawings in the dxf file format which can be opened later using the CAD software like LibreCAD. Thus, the Automated Building Drawings system allows the user to save all the drawings drawn into the computer thus user does not have to keep the old drawing sheets for future reference.

The basic workflow of using, by the user's point of view, will be to edit a normal text file. Then execution of the program will take place. The parsing will be done of the input file that user has just written and divided into small tokens. That can also be seen in a file named output.txt (just for debugging purposes).

\section{Technologies Used}
\subsection{C++}
\noindent C++ is one of the most popular programming languages and is implemented on a wide variety of hardware and operating system platforms. As an efficient compiler to native code, its application domains include systems software, application software, device drivers, embedded software, high- performance server and client applications, and entertainment software such as video games. Several groups provide both free and proprietary C++ compiler software, including the GNU Project, Microsoft, Intel and Embarcadero Technologies. C++ has greatly influenced many other
popular programming languages, most notably C\# and Java. Other successful languages such as Objective- C use a very different syntax and approach to adding classes to C.\\

\noindent Bjarne Stroustrup began his work on C with Classes in 1979. The idea of creating a new language originated from Stroustrups experience in programming for his Ph.D. thesis. Stroustrup found that Simula had features that were very helpful for large software development, but the language was too slow for practical use, while BCPL was fast but too low-level to be suitable for large software development. When Stroustrup started working in AT\&T Bell Labs, he had the problem of analyzing the UNIX kernel with respect to distributed computing. Remembering his Ph.D. experience, Stroustrup set out to enhance the C language with Simula-like features. C was chosen because it was general-purpose, fast, portable and widely used. Besides C and Simula, some other languages
that inspired him were ALGOL 68, Ada, CLU and ML. At first, the class, derived class, strong type checking, inlining, and default argument features were added to C via Stroustrups C++ to C compiler, Cfront. The first commercial implementation of C++ was released on 14 October 1985.

\subsection{Introduction To Qt}
\noindent Qt Creator is a complete IDE for creating applications with Qt Quick and the Qt application framework. Qt is designed for developing applications and user interfaces once and deploying them across several desktop and mobile operating systems. One of the major advantages of Qt Creator is that it allows a team of developers to share a project across different development platforms (Microsoft Windows, Mac OS X, and Linux) with a common tool for development and debugging.
In addition, UI designers can join the team by using Qt Quick tools for creating fluid user interfaces in close cooperation with the developers. The main goal for Qt Creator is meeting the development needs of Qt Quick developers who are looking for simplicity, usability, productivity, extendibility and openness, while aiming to lower the barrier of entry for newcomers to Qt Quick and Qt. The key features of Qt Creator allow UI designers and developers to accomplish the following tasks:
\begin{itemize}
\item Get  started  with  Qt  Quick  application  development  quickly  and  easily  with  examples,  tutorials,
and project wizards.
\item Design  application  user  interface  with  the  integrated  editor,  Qt  Quick  Designer,  or  use graphics
software to design the user interface and use scripts to export the design to Qt Quick Designer.
\item Develop  applications   with  the   advanced  code  editor  that  provides  new  powerful  features  for
copleting code snippets, refactoring code, and viewing the element hierarchy of QML files.
\item Build  and  deploy  Qt  Quick  applications  that  target  multiple  desktop and mobile platforms, such
as Microsoft Windows, Mac OS X, Linux, Symbian, MeeGo, and Maemo.
\item Debug  JavaScript  functions  and  execute  JavaScript  expressions  in  the  current  context,   and
inspect QML at runtime to explore the object structure, debug animations, and inspect colors.
\item Profile  your  Qt  Quick  applications  with  the  QML  Profiler.  You can inspect binding evaluations,
signal  handling,  and  painting  operations  when  running  QML  code.  This  is  useful  for  identifying
potential bottlenecks, especially in the evaluation of bindings.
\item Deploy  applications  to  mobile  devices  and  create  application  installation  packages  for  Symbian
and Maemo devices that can be published in the Ovi Store and other channels.
\item Easily access information with the integrated context­sensitive Qt Help system.
\item It has differents modes such as Welcome, edit debug, design,analyze and help
\end{itemize}

\subsection{dxflib}
dxflib is an open source C++ library mainly for parsing DXFTM files. QCAD, CAM Expert and vec2web all use dxflib to import DXF files. dxflib can also write DXF files, but you need to have good knowledge of the DXF format to produce valid output.

dxflib is a C++ library for reading and writing DXF files. When reading DXF files, dxflib parses the file and calls functions that you define in your own C++ class for adding entities, layers, ..
Please note that dxflib does not store any entities or other information for you. It only passes the supported entities and other objects found in the DXF file to your C++ class.
Using dxflib to read DXF files doesn't require any knowlege of the DXF format. However, it's still an advantage to know the basics about entities, attributes, layers and blocks. To write DXF files with dxflib you definitely need an idea of how a DXF file is organized.
dxflib does not depend on any exotic other libraries, just the standard C / C++ libraries.

\subsubsection{Features}
\subsubsection*{Supported DXF Format Sections}
\begin{lstlisting}
HEADER
	Variables
TABLES
	LAYER
BLOCKS
ENTITIES
	3DFACE
	ARC
	CIRCLE
	DIMENSION
		Aligned
		Linear
		Radial
		Diametric
		Angular
		Leader
	ELLIPSE
	HATCH
	INSERT
	LINE
	LWPOLYLINE
	POINT
	POLYLINE
	SPLINE
	SOLID
	TEXT
\end{lstlisting}

\subsubsection{Compiling dxflib}
\subsubsection*{Unix / Linux}

Under Unix and Linux Systems, compiling dxflib is a simple standard procedure:

\begin{verbatim*}
./configure
make
\end{verbatim*}

This creates the file './lib/dxflib.a' . To compile a dynamic version of dxflib, run 'make shared' instead of 'make' . This will create the file 
'./lib/libdxf.so.2.0.x.x' and the link './lib/libdxf.so' that points to './lib/libdxf.so.2.0.x.x' .
Instead of running 'make install', you can also copy the header files into a header directory of your choice and copy the library files into a library directory of your choice.

\subsubsection*{Windows}
There are many different ways to compile dxflib under Windows. You can use Microsoft's Visual C++ compiler, Borland's C++ command line tools, gcc and many other compilers. 
For this manual, only the process of compiling dxflib using cygwin [CYGWIN] and the gcc compiler from the MinGW32 package is shown:
\begin{verbatim*}
./configure
MinGW32-make
\end{verbatim*}
\subsubsection{Reading DXF Files}
\begin{figure}
\centering
\includegraphics[scale=0.8]{images/dxflib.png}
\caption{dxflib workflow}
\label{fig:dxflib}
\end{figure}

dxflib parses DXF files and calls functions in your class. In those functions you can for example add the entities to an entity container. The basic workflow can be seen in the Figure \ref{fig:dxflib}.

\subsubsection{Implementing the Creation Interface}
Your C++ class that handles DXF entities has to be derived from DL\_CreationInterface or DL\_CreationAdapter. In most cases DL\_CreationAdapter is more convenient because it doesn't force you to implement all functions.
\begin{verbatim}
class MyDxfFilter : public DL_CreationAdapter {
    virtual void addLine(const DL_LineData& d);
    ...
}
\end{verbatim}


The implementation of the functions in your class will typically add the entities to a container of entities or use the information in another way.

\begin{verbatim}
void MyDxfFilter::addLine(const DL_LineData& d) {
    std::cout << "Line: " << d.x1 << "/" << d.y1
    << " " << d.x2 << "/" << d.y2 << std::endl;
}
\end{verbatim}

When reading a DXF file you simply pass on a reference to an object of your class to the parser.

\begin{verbatim}
MyDxfFilter f;
DL_Dxf* dxf = new DL_Dxf();
if (!dxf->in("drawing.dxf", &f)) {
    std::cerr << "drawing.dxf could not be opened.\n";
}
delete dxf;
\end{verbatim}



\subsubsection{Writing DXF Files}
To write a DXF file, you need to wrap the entities, layers, blocks, .. you have into the wrapper classes of dxflib. Since dxflib does not store any entities, you need to iterate through your entities and call the write functions for each of them. Please note that you have to stick to the exact order in which you call the write functions of dxflib. Otherwise your DXF file will not be standard conform.

\subsubsection{Creating the Writer Object}
To create a DXF writer object you need to specify the file name as well as the DXF version you want to produce. At the time of writing only two DXF versions were supported: R12 and DXF 2000/2002. The dxflib codes for DXF version R12 is DL\_Codes::AC1009 and for DXF 2000/2002 DL\_Codes::AC1015.
There are two APIs you will need to write a DXF file. The API in DL\_WriterA offers low level functions to write basic key/value tuples on which a DXF file is based. Creating a valid DXF file using only these functions would be very difficult and inconvenient. Therefore, there is a higher level API in the DL\_Dxf class which allows you to write for example a whole line without knowing the key/value tuples that are needed for it.


\subsubsection{Writing the DXF Header}
\subsubsection*{Opening the DXF Header}
The DXF header contains information about the DXF version. It has to be written before anything else with
\begin{verbatim}
dxf.writeHeader(*dw);
\end{verbatim}
The following list shows how a DXF header typically looks like:
\begin{verbatim}
999
dxflib 2.0.4.8
  0
SECTION
  2
HEADER
  9
$ACADVER
  1
AC1015
  9
$HANDSEED
  5
FFFF
\end{verbatim}

As you can see, the writeHeader() function does not close the header. This is because you might want to store a set of variables into it. If you have to store variables, you have to do it now. If not, proceed with "Closing the Header".

\subsubsection*{Storing Additional Variables}
Variables in the DXF header are used to store meta data for the drawing contained in the file. For a description of all supported variables, please refer to the DXF documentation [DXF].
The following code snippet shows examples for storing variables of different types. You can store as many variables as you need but you have to stick to the supported variable names and types in order to create a valid DXF file.


The following code creates and opens a file for a DXF 2000/2002 drawing:
\begin{verbatim}
DL_Dxf dxf;
DL_Codes::version exportVersion = DL_Codes::AC1015;
DL_WriterA* dw = dxf.out("myfile.dxf", exportVersion);
if (dw==NULL) {
    printf("Cannot open file 'myfile.dxf' \
            for writing.");
    // abort function e.g. with return
}
\end{verbatim}


\begin{verbatim}
// int variable:
dw->dxfString(9, "$INSUNITS");
dw->dxfInt(70, 4);
// real (double, float) variable:
dw->dxfString(9, "$DIMEXE");
dw->dxfReal(40, 1.25);
// string variable:
dw->dxfString(9, "$TEXTSTYLE");
dw->dxfString(7, "Standard");
// vector variable:
dw->dxfString(9, "$LIMMIN");
dw->dxfReal(10, 0.0);
dw->dxfReal(20, 0.0);
\end{verbatim}

\subsubsection*{Closing the Header}
Use the following code to close the DXF header (end the current section):
\begin{verbatim}
dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Tables Section}
\subsubsection*{Opening the Tables Section}
The tables section of a DXF file contains some tables defining viewports, linestyles, layers, etc.
Open the tables section with the function:
\begin{verbatim}
dw->sectionTables();
\end{verbatim}

\subsubsection*{Writing the Viewports}
Viewports are not directly supported by dxflib. However, they still need to be there in a valid DXF file. You can write the standard viewports using the function:
\begin{verbatim}
dxf.writeVPort(*dw);
\end{verbatim}

\subsubsection*{Writing the Linetypes}
Only linetypes that are actually used need to be defined in the DXF file. For simplification, you might want to store all linetypes supported by dxflib as shown below.
\begin{verbatim}
dw->tableLineTypes(25);
dxf.writeLineType(*dw, DL_LineTypeData("BYBLOCK", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BYLAYER", 0));
dxf.writeLineType(*dw,
    DL_LineTypeData("CONTINUOUS", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO02W100", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO03W100", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO04W100", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("ACAD_ISO05W100", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BORDER", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BORDER2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("BORDERX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("CENTER", 0));
dxf.writeLineType(*dw, DL_LineTypeData("CENTER2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("CENTERX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHDOT", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHDOT2", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("DASHDOTX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHED", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHED2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DASHEDX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DIVIDE", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DIVIDE2", 0));
dxf.writeLineType(*dw, 
    DL_LineTypeData("DIVIDEX2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DOT", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DOT2", 0));
dxf.writeLineType(*dw, DL_LineTypeData("DOTX2", 0));
dw->tableEnd();
\end{verbatim}



\subsubsection*{Writing the Layers}
Layers are a substantial part of most DXF drawings. All layers that are used in the drawing need to be defined in this table section. The following example code writes three layers with names "0", "mainlayer" and "anotherlayer" to the DXF file. Note that before writing the layers, you need to specify how many layers there are in total. Layer "0" is the default layer. It cannot be omitted.

\begin{verbatim}
int numberOfLayers = 3;
dw->tableLayers(numberOfLayers);

dxf.writeLayer(*dw, 
    DL_LayerData("0", 0), 
    DL_Attributes(
        std::string(""),      // leave empty
        DL_Codes::black,      // default color
        100,                  // default width
        "CONTINUOUS"));       // default line style

dxf.writeLayer(*dw, 
    DL_LayerData("mainlayer", 0), 
    DL_Attributes(
        std::string(""),
        DL_Codes::red,
        100,
        "CONTINUOUS"));

dxf.writeLayer(*dw, 
    DL_LayerData("anotherlayer", 0), 
    DL_Attributes(
        std::string(""),
        DL_Codes::black,
        100,
        "CONTINUOUS"));

dw->tableEnd();
\end{verbatim}

The default line width is given in 1/100mm. The color enum in namespace DL\_Codes defines the most common colors.
Writing Various Other Tables
These tables are also needed. For more information, please refer to the DXF documentation [DXF].
\begin{verbatim}
dxf.writeStyle(*dw);
dxf.writeView(*dw);
dxf.writeUcs(*dw);

dw->tableAppid(1);
dw->tableAppidEntry(0x12);
dw->dxfString(2, "ACAD");
dw->dxfInt(70, 0);
dw->tableEnd();

Writing Dimension Styles
Dimension Styles define the look of dimensions.
dxf.writeDimStyle(*dw, 
    arrowSize, 
    extensionLineExtension, 
    extensionLineOffset, 
    dimensionGap, 
    dimensionTextSize);
\end{verbatim}

\subsubsection*{Writing Block Records}
Block records define the names of available blocks in the DXF file. The following example declares the existence of two blocks with names "myblock1" and "myblock2". Note that the first call is also needed. It opens the blocks table and writes some standard blocks that might be required by the DXF version.
\begin{verbatim}
dxf.writeBlockRecord(*dw);
dxf.writeBlockRecord(*dw, "myblock1");
dxf.writeBlockRecord(*dw, "myblock2");
dw->tableEnd();
\end{verbatim}



\subsubsection*{Ending the Tables Section}

\begin{verbatim}
dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Blocks Section}
The blocks section defines the entities of each block.

\begin{verbatim}
dw->sectionBlocks();

dxf.writeBlock(*dw, 
    DL_BlockData("*Model_Space", 0, 0.0, 0.0, 0.0));
dxf.writeEndBlock(*dw, "*Model_Space");

dxf.writeBlock(*dw, 
    DL_BlockData("*Paper_Space", 0, 0.0, 0.0, 0.0));
dxf.writeEndBlock(*dw, "*Paper_Space");

dxf.writeBlock(*dw, 
    DL_BlockData("*Paper_Space0", 0, 0.0, 0.0, 0.0));
dxf.writeEndBlock(*dw, "*Paper_Space0");

dxf.writeBlock(*dw,
    DL_BlockData("myblock1", 0, 0.0, 0.0, 0.0));
// ...
// write block entities e.g. with dxf.writeLine(), ..
// ...
dxf.writeEndBlock(*dw, "myblock1");

dxf.writeBlock(*dw,
    DL_BlockData("myblock2", 0, 0.0, 0.0, 0.0));
// ...
// write block entities e.g. with dxf.writeLine(), ..
// ...
dxf.writeEndBlock(*dw, "myblock2");

dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Entities Section}
The entities section defines the entities of the drawing. The two entities in the following example use the attributes of their layer (256 = color by layer, -1 = line width by layer, "BYLAYER" = line style by layer).




\begin{verbatim}
dw->sectionEntities();

// write all your entities..
dxf.writePoint(
    *dw,
    DL_PointData(10.0,
                 45.0,
                  0.0),
    DL_Attributes("mainlayer", 256, -1, "BYLAYER"));

dxf.writeLine(
    *dw,
    DL_LineData(25.0,   // start point
                30.0,
                 0.0,
               100.0,   // end point
               120.0,
                 0.0),
    DL_Attributes("mainlayer", 256, -1, "BYLAYER"));

dw->sectionEnd();
\end{verbatim}

\subsubsection{Writing the Objects Section}
\begin{verbatim}
dxf.writeObjects(*dw);
dxf.writeObjectsEnd(*dw);
\end{verbatim}
\subsubsection{Ending and Closing the File}
\begin{verbatim}
dw->dxfEOF();
dw->close();
delete dw;
\end{verbatim}

\subsection{libdxfrw}
\noindent libdxfrw is a free C++ library to read and write DXF files in both formats, ascii and binary form. It is licensed under the terms of the GNU General Public License version 2 (or at you option any later version).
\subsubsection*{Building and installing the library}
\begin{verbatim}
mkdir build
cd build
cmake ..
make
sudo make install
\end{verbatim}
\subsubsection*{For non-debug version}
\begin{verbatim}
mkdir release
cd release
cmake -DCMAKE_BUILD_TYPE=Release ..
make
sudo make install
\end{verbatim}
\subsubsection*{For UBUNTU/Mint Folks}
\begin{verbatim}
mkdir release
cd release
cmake - DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX:PATH=/usr .. && make all
make
sudo make install
\end{verbatim}



\subsection{Introduction to GitHub}
\noindent GitHub is a Git repository web-based hosting service which offers all of the functionality of Git as well as adding many of its own features. Unlike Git which is strictly a command-line tool, Github provides a web-based graphical interface and desktop as well as mobile integration. It also provides access control and several collaboration features such as wikis, task management, and bug tracking and feature requests for every project.\\

\noindent GitHub offers both paid plans for private repto handle everything from small to very large projects with speed and efficiency. ositories, and free accounts, which are usually used to host open source software projects. As of 2014, Github reports having over 3.4 million users, making it the largest code host in the world.\\

\noindent GitHub has become such a staple amongst the open-source development community that many developers have begun considering it a replacement for a conventional resume and some employers require applications to provide a link to and have an active contributing GitHub account in order to qualify for a job.

\subsection{What is Git?}
\noindent Git is a distributed revision control and source code management (SCM) system with an emphasis on speed, data integrity, and support for distributed, non-linear workflows. Git was initially designed and developed by Linus Torvalds for Linux kernel development in 2005, and has since become the most widely adopted version control system for software development.\\

\noindent As with most other distributed revision control systems, and unlike most client–server systems, every Git working directory is a full-fledged repository with complete history and full version-tracking capabilities, independent of network access or a central server. Like the Linux kernel, Git is free and open source software distributed under the terms of the GNU General Public License version 2 to handle everything from small to very large projects with speed and efficiency.\\

\noindent Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.

\subsection{Installation of Git}

Installation of git is a very easy process.
The current git version is: 2.0.4.
Type the commands in the terminal:\\\\
\emph{
\$ sudo apt-get update\\\\
\$ sudo apt-get install git\\\\}
This will install the git on your pc or laptop.

\subsection{Various Git Commands}

Git is the open source distributed version control system that facilitates GitHub activities on your laptop or desktop. The commonly used Git command line instructions are:-\\

\subsection*{Create Repositories}
\addcontentsline{toc}{subsection}{Create Repositories}
Start a new repository or obtain from an exiting URL

\begin{description}

\item [\$ git init [ project-name]]\\
Creates a new local repository with the specified name
\item [\$ git clone [url]]\\
Downloads a project and its entire version history

\end{description}


\subsection*{Make Changes}
\addcontentsline{toc}{subsection}{Make Changes}
Review edits and craft a commit transaction

\begin{description}

\item [\$ git status] \leavevmode \\
Lists all new or modified files to be committed

\item [\$ git diff] \leavevmode \\
Shows file differences not yet staged

\item [\$ git add [file]]\\
Snapshots the file in preparation for versioning

\item [\$ git reset [file]]\\
Unstages the file, but preserve its contents

\item [\$ git commit -m "[descriptive message]"]\\
Records file snapshots permanently in version history

\end{description}

\section{FreeCAD}
FreeCAD is a general purpose feature-based, parametric 3D modeler for CAD, MCAD, CAx, CAE and PLM, aimed directly at mechanical engineering and product design but also fits a wider range of uses in engineering, such as architecture or other engineering specialties. It is 100\% Open Source (LGPL2+ license) and extremely modular, allowing for very advanced extension and customization.

FreeCAD is based on OpenCasCade, a powerful geometry kernel, features an Open Inventor-compliant 3D scene representation model provided by the Coin 3D library, and a broad Python API. The interface is built with Qt. FreeCAD runs exactly the same way on Windows, Mac OSX, BSD and Linux platforms.

Home page: http://www.freecadweb.org

Documentation wiki: http://www.freecadweb.org/wiki

Forum: http://forum.freecadweb.org

Bug tracker: http://www.freecadweb.org/tracker

Git repository: https://github.com/FreeCAD/FreeCAD

Installing

Precompiled (installable) packages are available for Windows and Mac on the releases page at https://github.com/FreeCAD/FreeCAD/releases

On most Linux distributions, FreeCAD is directly installable from the software center application.

Other options are described at http://www.freecadweb.org/wiki/index.php?title=Download

****ADD UNIX INSTALLATION DETAIL HERE****


\section{Introduction to \LaTeX}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.2]{images/latex.png}
\caption{\LaTeX{} Logo}
\end{figure}
\hspace{-1.8em} \LaTeX{}, I had never heard about this term before doing this project,
but when I came to know about it's features, it is just excellent. 
\LaTeX (pronounced /ˈleɪtɛk/, /ˈleɪtɛx/, /ˈlɑːtɛx/, or /ˈlɑːtɛk/) is a 
document markup language and document preparation system for the \TeX{} 
typesetting  program. Within the typesetting system, its name is styled 
as \LaTeX.
\begin{figure}[ht]
\centering
\includegraphics[scale=0.4]{images/donald.jpg}
\caption{Donald Knuth, Inventor Of \TeX{} typesetting system}
\end{figure}

\hspace{-1.8em} Within the typesetting system, its name is styled as \LaTeX. The term 
\LaTeX{} refers only to the language in which documents are written, 
not to the editor used to write those documents. In order to create a 
document in \LaTeX, a .tex file must be created using some form of text 
editor. While most text editors can be used to create a \LaTeX{} document, 
a number of editors have been created specifically for working with \LaTeX.\\

\noindent\LaTeX{} is most widely used by mathematicians, scientists, 
engineers, philosophers, linguists, economists and other scholars in 
academia. As a primary or intermediate format, e.g., translating DocBook 
and other XML-based formats to PDF, \LaTeX{} is used because of the 
high quality of typesetting achievable by \TeX. The typesetting system 
offers programmable desktop publishing features and extensive facilities 
for automating most aspects of typesetting and desktop publishing, 
including numbering and cross-referencing, tables and figures, 
page layout and bibliographies.\\

\noindent\LaTeX{} is intended to provide a high-level language that
accesses the power of \TeX. \LaTeX{} essentially comprises a
collection of \TeX{} macros and a program to process \LaTeX documents. 
Because the \TeX{} formatting commands are very low-level, it is usually 
much simpler for end-users to use \LaTeX{}.


\subsection{Typesetting}
\LaTeX{} is based on the idea that authors should be able to focus on 
the content of what they are writing without being distracted by its 
visual presentation. in preparing a \LaTeX{} document, the author 
specifies the logical structure using familiar concepts such as 
chapter, section, table, figure, etc., and lets the \LaTeX{} system 
worry about the presentation of these structures. it therefore 
encourages the separation of layout from content while still allowing 
manual typesetting adjustments where needed. 

\begin{verbatim}
\documentclass[12pt]{article}
\usepackage{amsmath}
\title{\LaTeX}
\begin{document}
  \maketitle 
  \LaTeX{} is a document preparation system 
  for the \TeX{} typesetting program.
   \par 
   $E=mc^2$
\end{document}
\end{verbatim}

\subsection{Installing \LaTeX{} on System}
Installation of \LaTeX{} on personal system is quite easy. As i have used \LaTeX{} on Ubuntu 13.04 so i am discussing the installation steps for Ubuntu 13.04 here:
\begin{itemize}
\item Go to terminal and type\\\\
\textit{sudo apt-get install texlive-full}
\item Your Latex will be installed on your system and you can check for manual page by typing.\\\\
\textit{man latex}\\

in terminal which gives manual for latex command.
\item To do very next step now one should stick this to mind that the document which one is going to produce is written in any type of editor whether it may be your most common usable editor Gedit or you can use vim by installing first vim into your system using command.\\\\
\textit{sudo apt-get install vim}
\item After you have written your document it is to be embedded with some set of commands that Latex uses so as to give a structure to your document. Note that whenever you wish your document to be looked into some other style just change these set of commands.
\item When you have done all these things save your piece of code with .tex format say test.tex. Go to terminal and type\\\\
\textit{latex path of the file test.tex Or pdflatex path of the file test.tex\\ eg: pdflatex test.tex}\\
for producing pdf file simultaneously.\\
After compiling it type command\\\\
\textit{evince filename.pdf\\ eg: evince test.pdf}\\
To see output pdf file. 
\end{itemize}

\subsection{Making Graphics in \LaTeX{}}
\LaTeX{} s also know popularly for making complex graphics. One such example is shown below here:\\
\begin{verbatim}
\documentclass{article}
\usepackage{tikz}
\usetikzlibrary{calendar,shadings}
\renewcommand*{\familydefault}{\sfdefault}
\colorlet{winter}{blue}
\colorlet{spring}{green!60!black}
\colorlet{summer}{orange}
\colorlet{fall}{red}
\newcount\mycount
\begin{document}
\begin{tikzpicture}[transform shape,
every day/.style={anchor=mid,font=\tiny}]
\node[circle,shading=radial,outer color=blue!30,inner color=white,
minimum width=15cm] {\textcolor{blue!80!black}{\Huge\the\year}};
\foreach \month/\monthcolor in
{1/winter,2/winter,3/spring,4/spring,5/spring,6/summer,
7/summer,8/summer,9/fall,10/fall,11/fall,12/winter} {
\mycount=\month
\advance\mycount by -1
\multiply\mycount by 30
\advance\mycount by -90
\shadedraw[shading=radial,outer color=\monthcolor!30,middle color=white,
inner color=white,draw=none] (\the\mycount:5.4cm) circle(1.4cm);
\calendar at (\the\mycount:5.4cm) [
dates=\the\year-\month-01 to \the\year-\month-last]
if (day of month=1) {\large\color{\monthcolor!50!black}\tikzmonthcode}
if (Sunday) [red]
if (all) {
\mycount=1
\advance\mycount by -\pgfcalendarcurrentday
\multiply\mycount by 11
\advance\mycount by 90
\pgftransformshift{\pgfpointpolar{\mycount}{1.2cm}}};}
\end{tikzpicture}
\end{document}
\end{verbatim}\\
%\begin{figure}[ht]
%\centering
%\includegraphics[scale=0.4]{images/3d.png}
%\caption{Graphics in \LaTeX{}}
%\end{figure}
\LaTeX{} with just invoking few additional packages.

\subsection{Pdfscreen \LaTeX{}}
There are some packages that can help to have unified document using \LaTeX{}. Example of such a package is pdfscreen that let the user view it’s document in two forms-print and screen. Print for hard copy and screen for viewing your document on screen. Download this package from www.ctan.org/tex-archive/macros/latex/contrib/pdfscreen/.\\
Then install it using above mention method.\\

\noindent To test it the test code is given below:-\\
Just changing print to screen gives an entirely different view. But for working of pdfscreen another package required are comment and fancybox.\\

\noindent The fancybox package provides several different styles of boxes for framing and rotating content in your document. Fancybox provides commands that produce square-cornered boxes with single or double lines, boxes with shadows, and round-cornered boxes with normal or bold lines. You can box mathematics, floats, center, flushleft, and flushright, lists, and pages.\\
 	
\noindent Whereas comments package selectively include/excludes portions of text. The comment package allows you to declare areas of a document to be included or excluded. One need to make these declarations in the preamble of your file. The package uses a method for exclusion that is pretty robust, and can cope with ill-formed bunches of text.\\

\noindent So these extra packages needed to be installed on system for the proper working of pdfscreen package.
\section{Web based graphic generation using \LaTeX{}}
\LaTeX{} is also useful when there is need of generating the graphics from browser. For
example to draw a circle by just entering its radius in html input box. So this kind
A
of project can be conveniently handled using \LaTeX{}. Basic idea behind this generation
process is that when user clicks on submit button after entering radius a script will run
that enter the radius in already made .tex file and recompiles it on server and makes its
pdf and postscript file. After that user can view those files by clicking on link provided
to view the files. See some screen shots of such a graphic generation project made by
Dr. H.S. Rai:\\
So here in the above input page which is also the index page user can enter input
for length of rectangle, breadth of rectangle and for radius of circle after that user can submit the values. After the values get submitted a script get runs by php code at server
side. This script first enters the dimensions of rectangle and circle that were selected by
user in to an already existing .tex file and replace with the older dimensions there. After
that script recompiles the the tex file and make it available for user.\\
	
\noindent In above figure it gets clear that .tex file has been compiled and pdf and postscript files
are available to user and user can download the graphics so produced. Hence graphics
can be generated in \LaTeX{} through web interface.

\section{Objectives}
\begin{itemize}
\item To put views of your models in a 2D window and to insert that window in a drawing.
\item To increase the productivity and hence efficiency.
\item To encourage civil engineers to use the computer instead of drawing sheets.
\item To create the drawings of various entities without using the mouse.
\item To eliminate manual operations and thus saving the time and money by automating the entire drawing process.
\end{itemize}
